 g++ -std=c++14 -Wall a.cpp -o test.out

 ./test.out

 ## 시간 복잡도
 n!>2^n>n^2>nlogn>n>logn>1

 생각: 100억이상 ->절대안됨/10억이상->거의안됨/1억->어느정도는됨

  문제풀 때는 최고차항의 계수도 고려

  배열(Array)
- 참조 : O(1) 
- 탐색 : O(n)

배열(Vector)
- 참조 : O(1)
- 탐색 : O(n)
- 맨 끝, 앞에 삽입/삭제 : O(1) 
- 중간에 삽입 / 삭제 : O(n)

Stack
- n번째 참조 : O(n)
- 가장 앞부분 참조 : O(1)
- 탐색 : O(n)
- 삽입 / 삭제(n번째 제외) : O(1)

Queue
- n번째 참조 : O(n)
- 가장 앞부분 참조 : O(1)
- 탐색 : O(n)
- 삽입 / 삭제(n번째 제외) : O(1)

Double linked list
- 참조 : O(n)
- 탐색 : O(n)
- 삽입 / 삭제 : O(1)

map 
- 참조 : O(logn)
- 탐색 : O(logn)
- 삽입 / 삭제 : O(logn)

## 공간복잡도
"입력 크기에 대해 어떤 알고리즘이 실행되는데 필요한 메모리 공간의 양"

1.문제의 최대범위: 문제에서 주어진 최대범위를 기반으로 배열을 미리만든다.

2.문제의 메모리 제한:int타입 배열 기준, 보통 3000만 까지는 된다.

- 64MB: 1500만
- 128MB: 3000만 (보통여기)
- 256MB: 6000만
- 512MB: 1억2천만

## 누적합
 요소들의 누적된 합의 의미로 어떠한 배열을 기반으로 앞에서 부터 요소들의 누적된 합을 저장해 새로이 배열을 만들어서 이를 활용하는 것을 말합니다.

 ## 구현
 말그대로 문제 그대로 구현을 하면 됩니다. 

 ## 문제를 푸는 방법
 문제해석->손코딩->코드를작성O->반례체크

 

